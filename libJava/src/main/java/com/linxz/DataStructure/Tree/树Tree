二分搜索树：
二分搜索树(Binary Search Tree)，左边结点小于父结点，父结点小于右边结点(不会有相等的情况，真正情况下可以把相等放左结点或者右结点)
E有可比性，所以要继承Comparable
局限性：最差的情况下变成普通链表一样，递归很消耗性能
时间复杂度 O(h)  平均O(logn) 最差O(n)  全部结点都只有右结点的时候退化成单链表的结构


满二叉树：
一棵二叉树的结点要么是叶子结点，要么它有两个子结点（如果一个二叉树的层数为K，且结点总数是(2^k) -1，则它就是满二叉树。）


完全二叉树：
若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边，这就是完全二叉树。
添加结点的时候从上到下、从左到右添加。所以左右子树的高度差不会超过1。
通俗理解：数据从上到下、从左到右添加。类似于一层一层往下添加。


平衡二叉树：
它或者是一颗空树，或它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。
定义树的高度：左、右子树最高的树层数+1。(即总共有多少层) 叶子树高度为1。
定义平衡因子：左、右子树的高度差。平衡因子大于1表示这颗树不平衡了。
通俗点说：｜左子树的层树-右子树的层树｜<=1


线段树：
是一种平衡二叉树。
不是完全二叉树
线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点
                              A[0..........9]
                             /              \
                       A[0....4]         A[5....9]
                         /    \            /     \
                    A[0...1] A[2...4]   A[5..6]  A[7..9]
                       / \    /    \      /  \    /   \
                   A[0] A[1] A[2] A[3.4] A[5]A[6]A[7] A[8.9]
                                  /   \                /  \
                               A[3]  A[4]           A[8]   A[9]

AVL树：
是二分搜索树
最早的平衡二叉树。
在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。
为了解决什么问题：解决二分搜索树退化为链表。
LL:插入的元素在不平横的结点的左侧的左侧。(该结点平衡因子>1,该结点左子树平衡因子>=0)
RR:插入的元素在不平衡的结点的右侧的右侧。(该结点平衡因子<-1,该结点左子树平衡因子<=0)
LR:插入的元素在不平衡的结点的左侧的右侧。(该结点平衡因子>1,该结点左子树平衡因子<0)
RL:插入的元素在不平衡的结点的右侧的左侧。(该结点平衡因子<-1,该结点左子树平衡因子>0)
如：
(1)添加结点z之后，发现y结点不平衡了。(插入的元素在不平横的结点的左侧的左侧)  假设每个结点都有叶子结点T，T可以为空。
        y                              x
       / \                           /   \
      x   T4     向右旋转 (y)        z     y
     / \       - - - - - - - ->    / \   / \
    z   T3                       T1  T2 T3 T4
   / \
  T1  T2
  
(2)添加结点z之后，发现y结点不平衡了。(插入的元素在不平衡的结点的右侧的右侧)
        y                             x
      /  \                          /   \
     T1   x      向左旋转 (y)       y     z
         / \   - - - - - - - ->   / \   / \
       T2  z                     T1 T2 T3 T4
          / \
         T3 T4

(2)添加结点z之后，发现y结点不平衡了。(插入的元素在不平衡的结点的左侧的右侧)
       y                                       y                            z
      / \                                     / \                         /   \
     x  T4    向左旋转(x)，                   z   T4     向右旋转(y)       x      y
    / \       - - - - - - - - - - - ->     /  \       - - - - - - - >   / \    / \
   T1  Z                                  x   T3                       T1 T2  T3 T4
      / \                                / \
     T2 T3                              T1 T2

(3)添加结点z之后，发现y结点不平衡了。(插入的元素在不平衡的结点的右侧的左侧)
     y                                       y                               z
    /  \                                    /  \                           /   \
   T1   x       向右旋转(x)，               T1   Z     向左旋转(y)           y     x
       /  \    - - - - - - - - - - - ->        / \  - - - - - - - >      /  \   / \
      Z   T4                                  T2  X                     T1  T2 T3  T4
     / \                                         / \
    T2  T3                                      T3 T4

使用LL(y向右旋转)、RR(y向右旋转)，LR(x向左旋转，y向右旋转),RL(x向右旋转，y向左旋转)


最优二叉树（哈夫曼树）：
树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。


2-3树
满足二分搜索树的基本性质
结点可以存放一个元素或这两个元素
每个结点有两个孩子或者三个孩子。存放一个元素有两个孩子，存放两个元素有三个孩子。
是一棵绝对平衡的树
添加结点的时候，如果子结点为空则不添加到子结点(添加的结点永远不会添加到一个空的位置)，而是合并到这个结点上再去分离，如：

添加结点42,37,12,18,6,11,5

添加根结点        添加37,由于42左子树,合并上去           添加12到37的左子树,由于左子树是空结点合并上去
- - - - ->  42  - - - - - - - - - - - - - -> 37,42  - - - - - - - - - - - - - - - - - - - - ->  12,37,42


                                       37     添加18,有二分搜索性质可知要添加到12的右子树,      37
2-3树最多只能存放两个元素，因此要拆分     /   \    但不能直接添加到空的子结点                    /    \
- - - - - - - - - - - - - - - - ->  12   42  - - - - - - - - - - - - - - - - - - -->  12,18   42

                                                            37
                 37                                       /    \                                           12,37
添加结点6       /     \      对三个元素的结点拆分            12    42     为了绝对平衡,12需要于父结点融合          / |  \
- - - - - -> 6,12,18  42  - - - - - - - - - - ->        /  \        - - - - - - - - - - - - - - - ->     6   18  42
                                                       6   18


添加结点11       12,37        添加结点5        12,37      三个元素结点拆分       12,37
- - - - - ->   /   |  \    - - - - - ->     /  |  \   - - - - - - - - ->   /   |  \
            6,11  18  42               5,6,11  18  42                     6   18   42
                                                                         /  \
                                                                        5   11

                                    6,12,37
 为了绝对平衡,6需要于父结点融合       /  / \   \      三个元素结点拆分          12
- - - - - - - - - - - - - - ->   5  11  18 42   - - - - - - - - ->      /    \
                                                                       6      37
                                                                      /  \   /   \
                                                                     5   11  18  42
添加完成。等到一个绝对平衡的树。

红黑树
是二分搜索树
是平衡二叉树
算法导论的定义：
(1)每个结点不是红色就是黑色
(2)根结点一定是黑色的
(3)每一个叶子结点(或空结点)都是黑色的
(4)如果一个结点是红色的，那么它的孩子结点肯定都是黑色的
(5)从任意一个结点到叶子结点，经过的黑色结点都是一样d多的(红色结点不一定)
红黑树跟2-3树是等价的：

2-3树： a       b,c      红黑树:  a         b - c   为了表示b,c是并列关系,将b,c的边定义成红色，然后换成二分搜索树的样子  c
      /  \    / |  \            / \      /  \  \                                                              /  \
                                                                                                             b
                                                                                                            /  \
                                                                                                     (b,c的边绘制成红色表示两者并列)
由于没有定义边这个类，而每个结点与父结点只有一条边，所以可以在结点上定义属性表示该结点与父结点的边，比如定义该结点为红颜色，表示该结点与父结点是并列关系
红色结点其实是为了标记该结点到父结点的边是红色的(结点于父结点只有一个边，这样就不需要使用特殊的代码去定义边)
红色的结点一定都是左倾斜的
如：      42                                                 42                             42
        /   \       2-3树与红黑树对比                        /   \       即                  /   \
    17,33    50    - - - - - - - - - ->                  33     50    - - - ->      17 - 33    50
    / |  \   / \                                         /  \   /  \               / \    \    /  \
 6,12 18 37 48 66,88                                 17(红色)37 48  88        6 - 12  18   37  48  66 - 88
                                                       / \         /
                                                      12  18     66(红色)
                                                     /
                                                   6(红色)


红黑树是保持"黑平衡"的二叉树，即：根结点搜索到左右孩子叶子结点的过成黑结点的个数是一样多的。
严格意义上,不是平衡的二叉树。最大高度:2logn,即O(logn)

红黑树添加结点场景:
(1)2-3树中添加一个新元素(永远添加红色结点)
(2)或者添加进2-结点,形成一个3-结点(2-表示该结点有两个子树,3-表示有三个子树,4-表示有四个子树)
(3)或者添加进3-结点,暂时形成4-结点(三种情况)


(1)红黑树添加结点场景一:添加元素42
添加一个新元素(永远添加红色结点)            红黑树根结点一定是黑的,所以变颜色
- - - - - - - - - - - - - ->  42(红色) - - - - - - - - - - - - - - -> 42(黑色)


(2)红黑树添加结点场景二:37,42(左旋转)

                        37(黑色)
                            \
                           42(红色)
37与42其实是等价的,属于2-3中的同一个结点。为了表示等价使用红色结点红色边表示,所以红色的结点一定都是左倾斜的，所以需要进行左旋转
                        42(黑色)
                         /
                      37(红色)

即使:node.right=x.left
    x.left=node
    x.color=node.color
    node.color=RED



(3)红黑树添加结点场景三:42,37,66(颜色翻转)


添加元素42            添加元素37               红黑树表示   42(黑色)   添加元素66    42(黑色)   由2-3树的概念可知不能有三个元素的结点,故要拆分
- - - - ->  42(黑色) - - - - -> 42,37(2-3树) - - - - ->    /       -  - - - ->   /     \   - - - - - - - - - - - - - - - - - - - ->
                                                        37(红色)               37(红色) 66(红色)


拆分结点(中间结点变为父结点),直接黑颜即可       42(黑色)     拆分之后42结点需要往上一个结点融合,红色即可表示融合   42(红色)
- - - - - - - - - - - - - - - - - - ->    /      \    - - - - - - - - - - - - - - - - - - - - - - ->  /      \
                                        37(黑色)  66(黑色)                                           37(黑色)  66(黑色)

添加完成(颜色翻转flipColors)。


(4)红黑树添加结点场景:42,37,12(右旋转+颜色翻转)


添加元素42           添加元素37               红黑树表示   42(黑色)  添加元素12     42(黑色)   由2-3树的概念可知不能有三个元素的结点,故要拆分
- - - - -> 42(黑色) - - - - -> 42,37(2-3树) - - - - ->    /      -  - - - ->    /        - - - - - - - - - - - - - - - - - - - ->
                                                     37(红色)               37(红色)
                                                                             /
                                                                         12(红色)


右旋转             37(红色)      根据红黑树的定义维护颜色   37(黑色)    类似与场景二的情况了。拆分结点(改版颜色即可)    37(黑色)
- - - - - -- ->   /      \     - - - - - - - - - - ->  /     \    - - - - - - - - - - - - - - - - - - -->    /     \
              12(红色) 42(黑色)                       12(红色) 42(红色)                                     12(黑色) 42(黑色)



37结点向其父结点融合,即改为红色(颜色翻转)     37(红色)
- - - - - - - - - - - - - - - - - - ->  /      \
                                      12(黑色) 42(黑色)



(5)红黑树添加结点场景四:42,37,40(左旋转+右旋转+颜色翻转)

                            42(黑色)
                               /
                         37(红色)
                                \
                                40(红色)


                                               维持颜色    40(黑色)         拆分      40(黑色)      40向父结点融合     40(红色)
类似AVL树左旋转右旋然后颜色翻转   40(红色)        - - - - ->  /      \      - - - - ->  /      \   - - - - - - - ->    /      \
                              /     \                  37(红色) 42(红色)           37(黑色) 42(黑色)               37(黑色) 42(黑色)
                            37(红色) 42(黑色)


二分搜索树、AVL树、红黑树性能对比:
完全随机的数据普通的二分搜索树效率就很高。但极端情况下退化为链表(或者高度不平衡)
查询较多的情况下使用AVL树效率很高。
红黑树牺牲了平衡性(2logn),查询效率低;统计性能更优(综合增删该茶所有的操作)，所以经常要使用添加、删除操作(TreeMap,TreeSet)大都使用红黑树。


因为红黑树不是严格意义上的平衡树,高度可能为2logn,所以在查询效率上比AVL树上慢
整体来说红黑树是绝对平衡树，所以插入的时候效率比AVL树上快





B类树