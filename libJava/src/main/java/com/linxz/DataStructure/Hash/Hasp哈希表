    public int firstUniqChar2(String s) {
        int[] freq=new int[26];//类似一个哈希表，每一个字符都和一个索引对应

        //a-a   0
        //b-a   1
        //...             ->  index=ch - 'a' (哈希函数)
        //z-a  25

        ///索引查询是O(1)的查询操作

        for (int i=0;i<s.length();i++)
            freq[s.charAt(i)-'a']++;
        for (int i=0;i<s.length();i++)
            if (freq[s.charAt(i)-'a']==1)
                return i;
        return -1;
    }




哈希函数:
f(ch)=ch - 'a'
"键"通过哈希函数找到对应的索引(值)

哈希表:
根据哈希函数建立的表为哈希表

哈希冲突:
两个不同的"键"通过哈希函数找到相同的索引。(所以哈希表上的操作要考虑如果解决哈希冲突)



哈希表充分体现了算法设计领域的经典思想:空间换时间(多存储一些东西)
哈希设计在空间与时间上寻找一个平衡点


哈希冲突的处理:链地址法
比如:哈希表 table[0,1,2,3,4,5,6,7,8,9,...M-1]
k1对应的索引4，
k2对应的索引为1,
k3对应的索引为1，产生了哈希冲突，但是依然放到索引值为1的位置，但此处放的是链表(或者树,可以是任意的数据结构),即:table[4]->k2->k3

HashMap本质就是一个TreeMap的数组

Java8之前，每一个位置都对应一个链表
Java8开始，每一个位置也是对应一个链表，但是当哈希冲突达到一定程度的时候(如哈希表中对应的哈希冲突链表中的元素多于某个程度)，
就会把对应的链表转化为红黑树，即这个链表转为TreeMap。

数据量小的时候使用链表进行增删改查效率很高，而红黑树要经过各种旋转颜色翻转之类的导致效率很低。